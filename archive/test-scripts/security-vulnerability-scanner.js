#!/usr/bin/env node

/**
 * Advanced Security Vulnerability Scanner
 * Tests for XSS, IDOR, CSRF, SQL Injection, and more
 */

const puppeteer = require('puppeteer');
const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');

class SecurityVulnerabilityScanner {
  constructor(options = {}) {
    this.targetUrl = options.targetUrl || 'https://example.com';
    this.headless = options.headless || false;
    this.devtools = true;
    this.outputDir = options.outputDir || './test-results';
    this.findings = [];
  }

  async initialize() {
    console.log(chalk.blue('üîí Initializing Security Vulnerability Scanner...'));
    
    await fs.ensureDir(this.outputDir);
    
    this.browser = await puppeteer.launch({
      headless: this.headless,
      devtools: this.devtools,
      args: [
        '--disable-blink-features=AutomationControlled',
        '--disable-web-security',
        '--no-sandbox'
      ]
    });

    this.page = await this.browser.newPage();
    
    // Set up CDP session for advanced monitoring
    this.client = await this.page.target().createCDPSession();
    await this.client.send('Network.enable');
    await this.client.send('Runtime.enable');
    await this.client.send('Security.enable');
    
    // Monitor security events
    this.client.on('Security.securityStateChanged', (event) => {
      if (event.securityState === 'insecure') {
        this.addFinding({
          type: 'insecure_connection',
          severity: 'high',
          description: 'Insecure connection detected',
          details: event
        });
      }
    });

    console.log(chalk.green('‚úÖ Scanner initialized'));
  }

  addFinding(finding) {
    finding.timestamp = new Date().toISOString();
    this.findings.push(finding);
    
    const severityColor = {
      critical: chalk.red,
      high: chalk.red,
      medium: chalk.yellow,
      low: chalk.blue
    };
    
    const color = severityColor[finding.severity] || chalk.white;
    console.log(color(`üîç Finding [${finding.severity.toUpperCase()}]: ${finding.type} - ${finding.description}`));
  }

  async testXSS() {
    console.log(chalk.blue('üß™ Testing for XSS vulnerabilities...'));
    
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>',
      '<body onload=alert("XSS")>',
      '<input onfocus=alert("XSS") autofocus>',
      '<select onfocus=alert("XSS") autofocus>',
      '<textarea onfocus=alert("XSS") autofocus>',
      '<keygen onfocus=alert("XSS") autofocus>',
      '<video><source onerror="alert(\'XSS\')">',
      '<audio src=x onerror=alert("XSS")>'
    ];

    try {
      await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      
      // Find all input fields
      const inputs = await this.page.$$eval('input, textarea, select', elements => 
        elements.map(el => ({
          type: el.tagName.toLowerCase(),
          name: el.name || el.id || 'unnamed',
          id: el.id || null
        }))
      );

      for (const input of inputs) {
        for (const payload of xssPayloads) {
          try {
            // Try to inject payload
            if (input.type === 'input' || input.type === 'textarea') {
              await this.page.evaluate((selector, value) => {
                const el = document.querySelector(selector);
                if (el) el.value = value;
              }, `input[name="${input.name}"], textarea[name="${input.name}"], #${input.id}`);
            }

            // Check if alert was triggered (XSS successful)
            const alertTriggered = await this.page.evaluate(() => {
              return window.alertTriggered || false;
            });

            if (alertTriggered) {
              this.addFinding({
                type: 'xss_vulnerability',
                severity: 'high',
                description: `XSS vulnerability found in ${input.name || input.id}`,
                payload: payload,
                location: input
              });
            }
          } catch (e) {
            // Continue testing
          }
        }
      }
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  XSS test error: ${error.message}`));
    }
  }

  async testIDOR() {
    console.log(chalk.blue('üß™ Testing for IDOR vulnerabilities...'));
    
    try {
      await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      
      // Monitor network requests for ID patterns
      const idPatterns = [
        /\/api\/users\/(\d+)/,
        /\/api\/profile\/(\d+)/,
        /\/api\/account\/(\d+)/,
        /id=(\d+)/,
        /userId=(\d+)/,
        /user_id=(\d+)/
      ];

      this.page.on('response', async (response) => {
        const url = response.url();
        const status = response.status();
        
        for (const pattern of idPatterns) {
          const match = url.match(pattern);
          if (match && status === 200) {
            const id = match[1];
            
            // Try to access with different IDs
            const testIds = [1, 2, 999, 9999];
            for (const testId of testIds) {
              if (testId.toString() !== id) {
                const testUrl = url.replace(id, testId.toString());
                try {
                  const testResponse = await this.page.goto(testUrl, { waitUntil: 'networkidle0' });
                  if (testResponse && testResponse.status() === 200) {
                    this.addFinding({
                      type: 'idor_vulnerability',
                      severity: 'high',
                      description: `Potential IDOR: Can access resource with ID ${testId}`,
                      originalUrl: url,
                      testUrl: testUrl,
                      originalId: id,
                      testId: testId
                    });
                  }
                } catch (e) {
                  // Continue
                }
              }
            }
          }
        }
      });
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  IDOR test error: ${error.message}`));
    }
  }

  async testCSRF() {
    console.log(chalk.blue('üß™ Testing for CSRF vulnerabilities...'));
    
    try {
      await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      
      // Find all forms
      const forms = await this.page.$$eval('form', forms => 
        forms.map(form => ({
          action: form.action,
          method: form.method,
          hasCSRFToken: !!form.querySelector('input[name*="csrf"], input[name*="token"], input[name*="_token"]')
        }))
      );

      for (const form of forms) {
        if (!form.hasCSRFToken && (form.method === 'POST' || form.method === 'post')) {
          this.addFinding({
            type: 'csrf_vulnerability',
            severity: 'medium',
            description: `Form at ${form.action} may be vulnerable to CSRF (no CSRF token found)`,
            form: form
          });
        }
      }

      // Check for SameSite cookie attribute
      const cookies = await this.page.cookies();
      for (const cookie of cookies) {
        if (!cookie.sameSite || cookie.sameSite === 'None') {
          this.addFinding({
            type: 'csrf_cookie_issue',
            severity: 'medium',
            description: `Cookie ${cookie.name} may be vulnerable to CSRF (missing or None SameSite attribute)`,
            cookie: cookie.name
          });
        }
      }
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  CSRF test error: ${error.message}`));
    }
  }

  async testSQLInjection() {
    console.log(chalk.blue('üß™ Testing for SQL Injection vulnerabilities...'));
    
    const sqlPayloads = [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "' OR '1'='1' /*",
      "admin'--",
      "admin'/*",
      "' UNION SELECT NULL--",
      "1' AND '1'='1",
      "1' AND '1'='2"
    ];

    try {
      await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      
      const inputs = await this.page.$$('input[type="text"], input[type="email"], input[type="password"], textarea');
      
      for (const input of inputs) {
        for (const payload of sqlPayloads) {
          try {
            await input.type(payload);
            await this.page.keyboard.press('Enter');
            await this.page.waitForTimeout(1000);
            
            // Check for SQL error messages
            const pageContent = await this.page.content();
            const sqlErrors = [
              /SQL syntax/i,
              /mysql_fetch/i,
              /ORA-\d+/i,
              /PostgreSQL query failed/i,
              /Warning.*mysql_/i,
              /valid MySQL result/i,
              /MySqlClient/i
            ];

            for (const errorPattern of sqlErrors) {
              if (errorPattern.test(pageContent)) {
                this.addFinding({
                  type: 'sql_injection',
                  severity: 'critical',
                  description: `Potential SQL Injection vulnerability detected`,
                  payload: payload,
                  errorMessage: pageContent.match(errorPattern)[0]
                });
                break;
              }
            }
          } catch (e) {
            // Continue
          }
        }
      }
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  SQL Injection test error: ${error.message}`));
    }
  }

  async testSecurityHeaders() {
    console.log(chalk.blue('üß™ Testing security headers...'));
    
    try {
      const response = await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      const headers = response.headers();
      
      const requiredHeaders = {
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': /max-age=\d+/,
        'Content-Security-Policy': /.+/,
        'Referrer-Policy': /.+/
      };

      for (const [header, expected] of Object.entries(requiredHeaders)) {
        const value = headers[header.toLowerCase()];
        if (!value) {
          this.addFinding({
            type: 'missing_security_header',
            severity: 'medium',
            description: `Missing security header: ${header}`,
            header: header
          });
        } else if (typeof expected === 'object' && !Array.isArray(expected)) {
          // Regex check
          if (!expected.test(value)) {
            this.addFinding({
              type: 'weak_security_header',
              severity: 'low',
              description: `Weak or misconfigured header: ${header}`,
              header: header,
              value: value
            });
          }
        }
      }

      // Check for information disclosure
      if (headers['server']) {
        this.addFinding({
          type: 'information_disclosure',
          severity: 'low',
          description: `Server header exposes: ${headers['server']}`,
          header: 'Server',
          value: headers['server']
        });
      }
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  Security headers test error: ${error.message}`));
    }
  }

  async testAuthentication() {
    console.log(chalk.blue('üß™ Testing authentication mechanisms...'));
    
    try {
      await this.page.goto(this.targetUrl, { waitUntil: 'networkidle2' });
      
      // Check for default credentials
      const defaultCreds = [
        { username: 'admin', password: 'admin' },
        { username: 'admin', password: 'password' },
        { username: 'admin', password: '123456' },
        { username: 'test', password: 'test' }
      ];

      // Look for login forms
      const loginForm = await this.page.$('form[action*="login"], form[action*="signin"], input[type="password"]');
      
      if (loginForm) {
        // Try default credentials (commented out for safety - uncomment if needed)
        // for (const creds of defaultCreds) {
        //   // Test login
        // }
        
        this.addFinding({
          type: 'authentication_form_found',
          severity: 'info',
          description: 'Login form detected - manual testing recommended',
          recommendation: 'Test for weak passwords, account enumeration, brute force protection'
        });
      }
    } catch (error) {
      console.log(chalk.yellow(`‚ö†Ô∏è  Authentication test error: ${error.message}`));
    }
  }

  async generateReport() {
    console.log(chalk.blue('üìä Generating security scan report...'));
    
    const report = {
      timestamp: new Date().toISOString(),
      targetUrl: this.targetUrl,
      totalFindings: this.findings.length,
      findingsBySeverity: {
        critical: this.findings.filter(f => f.severity === 'critical').length,
        high: this.findings.filter(f => f.severity === 'high').length,
        medium: this.findings.filter(f => f.severity === 'medium').length,
        low: this.findings.filter(f => f.severity === 'low').length,
        info: this.findings.filter(f => f.severity === 'info').length
      },
      findings: this.findings
    };

    const jsonPath = path.join(this.outputDir, `security-scan-${Date.now()}.json`);
    await fs.writeJSON(jsonPath, report, { spaces: 2 });
    console.log(chalk.green(`‚úÖ Report saved: ${jsonPath}`));

    // Generate markdown
    const mdPath = path.join(this.outputDir, `security-scan-${Date.now()}.md`);
    const markdown = this.generateMarkdownReport(report);
    await fs.writeFile(mdPath, markdown);
    console.log(chalk.green(`‚úÖ Markdown report saved: ${mdPath}`));

    return report;
  }

  generateMarkdownReport(report) {
    return `# Security Vulnerability Scan Report

**Target:** ${report.targetUrl}  
**Date:** ${new Date(report.timestamp).toLocaleString()}  
**Total Findings:** ${report.totalFindings}

## Summary by Severity

- **Critical:** ${report.findingsBySeverity.critical}
- **High:** ${report.findingsBySeverity.high}
- **Medium:** ${report.findingsBySeverity.medium}
- **Low:** ${report.findingsBySeverity.low}
- **Info:** ${report.findingsBySeverity.info}

## Findings

${report.findings.map(f => `
### ${f.type} [${f.severity.toUpperCase()}]

**Description:** ${f.description}  
**Timestamp:** ${f.timestamp}

${f.payload ? `**Payload:** \`${f.payload}\`` : ''}
${f.location ? `**Location:** ${JSON.stringify(f.location)}` : ''}
${f.details ? `**Details:** ${JSON.stringify(f.details, null, 2)}` : ''}
`).join('\n')}

## Recommendations

1. Address all critical and high severity findings immediately
2. Review medium severity findings for potential impact
3. Implement security headers
4. Add CSRF protection to all state-changing operations
5. Implement input validation and output encoding
6. Regular security audits and penetration testing
`;
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
    }
  }
}

// Main execution
async function main() {
  const args = process.argv.slice(2);
  const targetUrl = args[0] || process.env.TARGET_URL || 'https://example.com';
  
  const scanner = new SecurityVulnerabilityScanner({
    targetUrl: targetUrl,
    headless: false,
    devtools: true,
    outputDir: './test-results'
  });

  try {
    await scanner.initialize();
    
    console.log(chalk.cyan('\nüîç Starting comprehensive security scan...\n'));
    
    await scanner.testSecurityHeaders();
    await scanner.testXSS();
    await scanner.testIDOR();
    await scanner.testCSRF();
    await scanner.testSQLInjection();
    await scanner.testAuthentication();
    
    // Wait a bit for all tests to complete
    await scanner.page.waitForTimeout(5000);
    
    await scanner.generateReport();
    
    console.log(chalk.green('\n‚úÖ Security scan complete!'));
    console.log(chalk.cyan('Browser will remain open for 30 seconds for manual inspection...\n'));
    
    await scanner.page.waitForTimeout(30000);
    await scanner.close();
    
  } catch (error) {
    console.error(chalk.red(`‚ùå Error: ${error.message}`));
    await scanner.close();
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = SecurityVulnerabilityScanner;

